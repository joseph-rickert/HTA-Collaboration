---
title: "3-state_S&F_JAGS"
format: html
---

```{r}
library(tidyverse)
```



## Dererministic Model
```{r}
s_state <- matrix(
  c(210, 61, 1,
    89, 645, 14,
    0, 0, 81),
  nrow = 3, byrow = TRUE,
  dimnames = list(c("S1", "S2", "S3"), c("S1", "S2", "S3"))
)

```

```{r}
estimate_Q <- function(state_counts) {
  n <- nrow(state_counts)
  Q <- matrix(0, n, n)
  
  for (i in 1:n) {
    total_transitions <- sum(state_counts[i, ])
    
    if (total_transitions == 0 || i == n) {
      Q[i, i] <- 0  # absorbing state
    } else {
      for (j in 1:n) {
        if (i != j) {
          Q[i, j] <- state_counts[i, j] / total_transitions
        }
      }
      Q[i, i] <- -sum(Q[i, -i])
    }
  }
  
  rownames(Q) <- colnames(Q) <- rownames(state_counts)
  return(Q)
}

Q <- estimate_Q(s_state)
Q

```
```{r}
library(expm)

t <- 1  # time interval
P_t <- expm(Q * t)
P_t

```
## JAGS Model

```{r}
library(rjags)
library(expm)
```



```{r}
model_string <- "
model {
  # Priors for off-diagonal rates
  Q[1,2] ~ dgamma(1, 0.1)
  Q[1,3] ~ dgamma(1, 0.1)
  Q[2,1] ~ dgamma(1, 0.1)
  Q[2,3] ~ dgamma(1, 0.1)

  # Diagonal elements: negative sum of outgoing rates
  Q[1,1] <- -(Q[1,2] + Q[1,3])
  Q[2,2] <- -(Q[2,1] + Q[2,3])
  Q[3,3] <- 0  # absorbing
  Q[3,1] <- 0
  Q[3,2] <- 0
}
"



```

```{r}

library(rjags)
library(coda)

# Prepare data (no likelihood in JAGS)
data_list <- list()

params <- c("Q")

jags_model <- jags.model(textConnection(model_string), data = data_list, n.chains = 3)
update(jags_model, 1000)
samples <- coda.samples(jags_model, variable.names = params, n.iter = 5000)

lambda_samples <- as.matrix(samples)[, grep("Q\\[", colnames(samples))]









```






# #######################

```{r}
samples_df <- as.data.frame(as.mcmc(do.call(rbind, samples)))
smry <- summary(samples)
Mean <- smry$statistics[, "Mean"]
Q_smry <- cbind(Mean, smry$quantiles)
round(Q_smry, 4)
```



## Set up fpr MCMC Trace Plots

```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"
# Convert mcmc.list to data frame and add chain + iteration info
df_long <- do.call(rbind, lapply(1:length(samples), function(chain) {
  as.data.frame(samples[[chain]]) %>%
    mutate(
      iteration = row_number(),
      chain = factor(chain)
    )
})) %>%
  pivot_longer(cols = -c(iteration, chain), 
               names_to = "parameter", 
               values_to = "value")
```





### Trace Plots

```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"
# Define the number of rows to sample
n_sample <- 10000

# Take a random sample of n_sample rows
#f) gets the total number of rows in the data frame
# sample(nrow(df), n_sample) generates n_sample random row indices
# df[...] then subsets the data frame using these random indices
random_sample_df <- df_long[sample(nrow(df_long), n_sample), ]
ggplot(random_sample_df %>% filter(parameter %in% 
                                     c("Q[1,1]", "Q[1,2]", "Q[1.3]", 
                                       "Q[2,1]", "Q[2,2]", "Q[2,3")), 
       aes(x = iteration, y = value, color = chain)) +
  geom_line(alpha = 0.6) + 
   facet_wrap(~parameter, scales = "free_y") +
  labs(title = "Trace Plots", x = "Iterations", y = "Parameter Value") +
  theme_minimal() +
  scale_x_continuous(breaks = n_sample)

```
# 
### Plot Posterior distributions.
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: true
#| code-summary: "Show the code"
ggplot(df_long %>% filter(parameter %in% 
                             c("Q[1,1]", "Q[1,2]", "Q[1.3]", 
                              "Q[2,1]", "Q[2,2]", "Q[2,3")), 
       aes(x = value, fill = parameter)) +
       geom_density(alpha = 0.5) +
       facet_wrap(~parameter, scales = "free") +
       xlim(0,1) +
       labs(title = "Posterior Densities", x = "Value", y = "Density") +
       theme_minimal()
```

```{r}
t <- 12  # time interval
P<- expm(Q * t)
P
```

