
---
title: "Solution to NMADA 3state asthma model"
author: Joseph Rickert
date: July 27, 2024
format: html
---

This document implents a `JAGS` model for the 4-state network meta-analysis model described in the book [Network Meta-Analysis for Decision-Making](https://www.agropustaka.id/wp-content/uploads/2020/04/agropustaka.id_buku_Network-Meta-Analysis-for-Decision-Making.pdf) by Sofia Dias, A.E. Ades, Nicky J. Welton, Jeroen P. Jansen, and Alexander J. Sutton.





## Load and Prepare Data

```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"
library(rjags)
library(ggplot2)
library(coda)
library(dplyr)
library(tidyr)
```

## Define the JAGS Model

The ransition probabilities P[i,j] were derived from by symbolically solving the Kolmogorov forward equations using the Julia language and translated into R syntax which is understood by `JAGS`. The original very long Julia expressions were also broken down into smaller terms to make them more easily digestible by the `JAGS` compiler
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Code for JAGS Model String"
model_string <- "
model {

# Multinomia Likelihood
# for (i in 1:3){ r[i, 1:3] ~ dmulti(P[i, 1:3], n[i])
#     }


q1 <- Q[1,2] + Q[1,3]
q2 <- Q[2,1] + Q[2,3]

h <- sqrt( (q1 - q2)^2 + 4 * Q[1,2] * Q[2,1] )
e1 <- exp(-.5*(q1 + q2 - h) * t) 
e2 <- exp(-.5*(q1 + q2 + h) * t) 


P[1,1] <- ( (-q1 + q2 + h) * e1 + (q1 - q2 + h) * e2) / (2 * h)
P[1,2] <- (( -q1 + q2 + h) * (q1 - q2 + h) * (e1 - e2)) / ( 4 * h * Q[2,1])
P[1,3] <- 1 - P[1,1] - P[1,2]
P[2,1]  <- Q[2,1] * (e1 - e2) / h
P[2,2] <- ((q1 - q2 + h) * e1 + (-q1 + q2 + h) * e2) / (2 * h)
P[2,3] <- 1 - P[2,1] - P[2,2]
P[3,1] <- 0
P[3,2] <- 0
P[3,3] <- 1


# Normalized transition probabilities are used to stabilize the model
# If p[1,j] is exactly 0 or NA due to symbolic math breakdowns 
# (e.g., division by row2_sum = 0), the likelihood becomes invalid
# triggering that dreaded “Invalid parent values” error.
# max(max(...), ε) acts like a soft-clipping threshold to guarantee numerical safety.

# ---------- p[1,j] ---------- 

row1_sum <- P[1,1] + P[1,2] + P[1,3]

p[1,1] <- max(max(P[1,1] / row1_sum, 0), 0.000001)
p[1,2] <- max(max(P[1,2] / row1_sum, 0), 0.000001)
p[1,3] <- max(max(P[1,3] / row1_sum, 0), 0.000001)


r[1,1:3] ~ dmulti(p[1,1:3], n[1])


# ---------- p[2,j] ---------- 

row2_sum <- P[2,1] + P[2,2] + P[2,3] 

p[2,1] <- max(max(P[2,1] / row2_sum, 0), 0.000001)
p[2,2] <- max(max(P[2,2] / row2_sum, 0), 0.000001)
p[2,3] <- max(max(P[2,3] / row2_sum, 0), 0.000001)


r[2,1:3] ~ dmulti(p[2,1:3], n[2])

# ---------- p[3,j] ---------- 
 
row3_sum <- P[3,1] + P[3,2] + P[3,3]


p[3,1] <- max(max(P[3,1] / row3_sum, 0), 0.000001)
p[3,2] <- max(max(P[3,2] / row3_sum, 0), 0.000001)
p[3,3] <- max(max(P[3,3] / row3_sum, 0), 0.000001)


r[3,1:3] ~ dmulti(p[3,1:3], n[3])






# Priors for transition rates

Q[1,2] ~ dgamma(0.1, 0.1)
Q[1,3] ~ dgamma(0.1, 0.1)

Q[1,1] <- -(Q[1,2] + Q[1,3])

# Priors from state 2
Q[2,1] ~ dgamma(0.1, 0.1)
Q[2,3] ~ dgamma(0.1, 0.1)

Q[2,2] <- -(Q[2,1] + Q[2,3])

# Priors for state 3 
Q[3,1] ~ dgamma(0.1, 0.1)
Q[3,2] ~ dgamma(0.1, 0.1)

Q[3,3] <- -Q[3,1] - Q[3,2]
}
"   
writeLines(model_string, "3-state.bug")
```

## Run the JAGS Model


```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"
#| 
# Initialize model

r <- matrix(c(310,    72,  0,
               97,  1716, 13,
                0,     0, 94),  nrow=3, ncol=3, byrow=TRUE)

n <- rowSums(r)
 

data_list <- list(
  r = r,
  n = n,
  t = 12)

# Rate matrix Q

inits <- function() {
  list(
    Q = matrix(c(0.0, 0.1, 0.1,
                 0.1, 0.0, 0.1,
                 0.1, 0.1, 0.0), nrow=3, byrow=TRUE)
  )
}


              
parameters.to.save = c("Q[1,1]", "Q[1,2]", "Q[1,3]", 
                       "Q[2,1]", "Q[2,2]", "Q[2,3]", 
                       "Q[3,1]", "Q[3,2]", "Q[3,3]",
                       "P[1,1]", "P[1,2]", "P[1,3]", 
                       "P[2,1]", "P[2,2]", "P[2,3]",
                       "P[3,1]", "P[3,2]", "P[3,3]",
                       "p[1,1]", "p[1,2]", "p[1,3]", 
                       "p[2,1]", "p[2,2]", "p[2,3]", 
                       "p[3,1]", "p[3,2]", "p[3,3]"
                       )

jags_model <- jags.model(file = "3-state.bug",
                         data = data_list,
                         n.chains = 3,
                         n.adapt = 100)
                         

# Burn-in
update(jags_model, 10000) #Discard these samples
``` 
This code uses the `coda.samples` function to draw samples from the JAGS model. The number of iterations is set to 5000, which can be adjusted based on convergence diagnostics and model complexity.
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"


samples <- coda.samples(jags_model,
  variable.names = c(
    "Q[1,1]", "Q[1,2]", "Q[1,3]", 
    "Q[2,1]", "Q[2,2]", "Q[2,3]", 
    "Q[3,1]", "Q[3,2]", "Q[3,3]", 
    "P[1,1]", "P[1,2]", "P[1,3]",  # cap P are the transition probabilities
    "P[2,1]", "P[2,2]", "P[2,3]", 
    "p[1,1]", "p[1,2]", "p[1,3]",  # small p are the normalized transition
    "p[2,1]", "p[2,2]", "p[2,3]",  # probabilities use to stabilize the model
    "p[3,1]", "p[3,2]", "p[3,3]"
  ),
  n.iter = 50000,
  n.thin = 10
)


```


This code constructs, P, the matrix of transition probabilities. Prints out P and the row sums of P. Since P is a stochastic matrix, the row sums should be 1.
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: true
#| code-summary: "Show the code"

states <- c("STW", "UTW-X", "F")
smry <- summary(samples)
smry_df <- as.data.frame(smry[1])
names(smry_df) <- c("Mean", "SD", "Naive_SE", "Time_Series_SE")
P_rows <- smry_df[grep("^P\\[", rownames(smry_df)), ]

P <- matrix(P_rows[,1], nrow = 3, ncol = 3, byrow = TRUE)
colnames(P) <- states
rownames(P) <- states
P
rowsum_P <- rowSums(P)
names(rowsum_P) <- c("Row1", "Row2", "Row3")
rowsum_P
```
This code constructs the Generator matrix for the Markov, which contains the process rates, lambda. Rows of the generator matrix should sum to 0.

```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: true
#| code-summary: "Show the code"

Q_rows <- smry_df[grep("^Q", rownames(smry_df)), ]
Q <- matrix(Q_rows[,1], nrow = 3, ncol = 3, byrow = TRUE)
colnames(Q) <- states
rownames(Q) <- states
Q
cat("\n row sums:")
rowsum_Q <- rowSums(Q)
names(rowsum_Q) <- c("Row1", "Row2", "Row3")
rowsum_Q
```
This code constructs the matrix p of normalized transition probabilities matrix. These were computed by `JAGS` as a check on the stabiliy of the model. P and p should agree fairly closely.

```{r}
#| message: FALSE
#| warning: FALSE
#| eval: FALSE
#| code-fold: true
#| code-summary: "Show the code"

p_rows <- smry_df[grep("^p\\[", rownames(smry_df)), ]
p <- matrix(P_rows[,1], nrow = 3, ncol = 3, byrow = TRUE)
colnames(p) <- states
rownames(p) <- states
p
rowsum_p <- rowSums(p)
names(rowsum_p) <- c("Row1", "Row2", "Row3")
rowsum_p
```


This code sets up for plotting MCMC diagnostics. 
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: true
#| code-summary: "Show the code"
# Convert JAGS samples to a data frame
samples_df <- as.data.frame(as.mcmc(do.call(rbind, samples)))


# Optional: print a few raw samples
cat("\n Transition Probabilities:\n")
round(head(samples_df[,1:6]),3)

cat("\n Process Rates:\n")
round(head(samples_df[,7:15]),3)
```

## Plots of MCMC Traces.
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"
# Convert mcmc.list to data frame and add chain + iteration info
df_long <- do.call(rbind, lapply(1:length(samples), function(chain) {
  as.data.frame(samples[[chain]]) %>%
    mutate(
      iteration = row_number(),
      chain = factor(chain)
    )
})) %>%
  pivot_longer(cols = -c(iteration, chain), 
               names_to = "parameter", 
               values_to = "value")

```

### Trace Plots
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: TRUE
#| code-summary: "Show the code"
ggplot(df_long %>% filter(parameter %in% c("P{1,1]", "P[1,2]", "P[1,3]", 
                                           "P[2,1]", "P[2,2]", "P[2,3]", 
                                           "P[3,1]", "P[3,2]", "P[3,3]")), 
       aes(x = iteration, y = value, color = parameter)) +
  geom_line(alpha = 0.6) +
  facet_wrap(~parameter, scales = "free_y") +
  labs(title = "Trace Plots", x = "Iteration", y = "Parameter Value") +
  theme_minimal()
```

### Plot Posterior distributions.
```{r}
#| message: FALSE
#| warning: FALSE
#| code-fold: true
#| code-summary: "Show the code"
ggplot(df_long %>% filter(parameter %in% c("P[1,1]", "P[1,2]", "P[1,3]", 
                                           "P[2,1]", "P[2,2]", "P[2,3]")), 
       aes(x = value, fill = parameter)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~parameter, scales = "free") +
  labs(title = "Posterior Densities", x = "Value", y = "Density") +
  theme_minimal()

```
